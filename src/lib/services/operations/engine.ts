import { prisma } from '@/lib/db'

type CreatedEvent = {
  id: string
  title: string
  room: string | null
  startsAt: Date
  endsAt: Date
}

export class OperationsEngine {
  async onEventCreated(event: CreatedEvent) {
    const [inventoryAlerts, scheduleGaps] = await Promise.all([
      this.checkInventory(),
      this.checkTeacherSchedule(event),
    ])

    const shadowTickets = [
      ...inventoryAlerts.map((name) => `Inventory low: ${name}`),
      ...scheduleGaps.map((gap) => `Schedule gap: ${gap}`),
    ]

    if (shadowTickets.length === 0) {
      shadowTickets.push(`Pre-event facilities review required for ${event.title}`)
    }

    await Promise.all(
      shadowTickets.map((title) =>
        prisma.ticket.create({
          data: {
            title,
            description: `Auto-generated by OperationsEngine from Event ${event.id}`,
            source: 'SHADOW_EVENT_AUTOMATION',
          } as any,
        })
      )
    )
  }

  private async checkInventory(): Promise<string[]> {
    const lowItems = await prisma.inventoryItem.findMany({
      where: {
        quantityOnHand: { lte: 5 },
      },
      select: { name: true },
      take: 5,
    })
    return lowItems.map((item) => item.name)
  }

  private async checkTeacherSchedule(event: CreatedEvent): Promise<string[]> {
    const day = event.startsAt.getDay()
    const schedules = await prisma.teacherSchedule.findMany({
      where: { dayOfWeek: day },
      select: { teacherName: true, periodStart: true, periodEnd: true },
    })

    const eventStart = event.startsAt.toTimeString().slice(0, 5)
    const eventEnd = event.endsAt.toTimeString().slice(0, 5)
    const gaps = schedules
      .filter((slot) => slot.periodEnd < eventStart || slot.periodStart > eventEnd)
      .slice(0, 3)
      .map((slot) => `${slot.teacherName} outside event window`)

    return gaps
  }
}

export const operationsEngine = new OperationsEngine()
